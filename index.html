<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <title>Directions service</title>
    <link href="css\bootstrap.css" rel="stylesheet">
    <link href="styles.css" rel="stylesheet" media="screen">
    <script type="text/javascript" src="js\jquery-1.11.3.min.js"></script>
  </head>

  <body>
   
    <div class="contain">
      <!-- start solidPanel -->
      <div class="panel" id="solidPanel">
        
        <!-- Cancel Button -->
        <div>
          <button  id="clearButtonSolid" class="button buttonSolid" type="button">X</button>
        </div>  

        <!-- Starting Location Field -->
        <div class="nav-row-Solid">
          <div class="input-frame col-xs-12">
            <div class="labelSolid">O</div>
            <div class="frameSolid">
              <input type="text" placeholder="Enter Origin Address" id="startSolid"  class="input-field-Solid ">
              <div class="underlineSolid"></div>
            </div>
          </div>

        </div><!-- end nav-row -->

        <!-- End Destination Field -->
        <div class="nav-row-Solid">
          <div class="input-frame col-xs-12">
            <div class="labelSolid">D</div>
            <div class="frameSolid">
              <input type="text" placeholder="Enter Destination" id="endDestinationSolid"  class="input-field-Solid">
              <div class="underlineSolid"></div>
            </div>
          </div>

        </div><!-- end nav-row -->

        <!-- Add Button -->
        <div class="addDestination">
          <button id="addButtonSolid" class="button buttonCircle buttonSolid buttonRight" type="button">+</button>
        </div>

        <div class="bottomBarSolid">
          <!-- Optimize Route Button -->
          <button id="optimizeButton" class="button buttonSquared buttonSolid" type="button" disabled>Optimize Route</button>
          <!-- Get Route Button -->
          <button id="goButtonSolid" class="button buttonSquared buttonSolid buttonRight" type="button">Get Route</button>
        </div>

        <div id="routeInfoDisplay"></div> 

      </div><!-- end solidPanel --> 

      <!-- start floatingPanel -->
      <div class="panel" id="floatingPanel">
        <div class="topBar"></div>

        <!-- Cancel Button -->
        <div>
          <button id="clearButtonFloat" class="button buttonFloat" type="button">X</button>
        </div>  

        <!-- Starting Location Field -->
        <div class="nav-row start-row">        
          <div class="input-frame frameFloat">
            <input type="text" placeholder="Enter Origin Address" id="startFloat"  class="input-field">
            <div class="underline"></div>
          </div><!-- end input-frame -->

        </div> <!-- end nav-row -->

        <!-- End Destination Field -->
        <div class="nav-row destination-row">
          <div class="input-frame frameFloat">
            <input type="text" placeholder="Enter Destination Address 1"  id="endDestinationFloat" class="input-field">
            <div class="underline"></div>
          </div><!-- end input-frame -->
        </div> <!-- end nav-row --> 
      
        <!-- Add Button -->
        <div class="addDestination">
          <button id="addButtonFloat" class="button buttonCircle buttonFloat buttonRight" type="button">+</button>
        </div>

        <!-- Get Directions Button -->
        <div class="bottomBarFloat">
          <button id="goButtonFloat" class="button buttonSquared buttonFloat buttonRight" type="button">Get Directions</button>
        </div>

      </div><!-- end floatingPanel -->

    </div><!-- end contain -->


    <div id="map"></div>

    <script>
     
      //DESCRIPTION: Assignment of Button Names/References
      var container = document.querySelector('.contain');

      var clearButtonSolid = document.querySelector('#clearButtonSolid');
      var addButtonSolid = document.querySelector('#addButtonSolid');
      var goButtonSolid = document.querySelector('#goButtonSolid');
      var optimizeButton = document.querySelector('#optimizeButton');

      var clearButtonFloat = document.querySelector('#clearButtonFloat');
      var addButtonFloat = document.querySelector('#addButtonFloat');
      var goButtonFloat = document.querySelector('#goButtonFloat');
     
     //DESCRIPTION: copies Origin & Destination input values from floatingPanel to solidPanel 
      var floatToSolid = function() {
        document.getElementById('startSolid').value = document.getElementById('startFloat').value;
        document.getElementById('endDestinationSolid').value = document.getElementById('endDestinationFloat').value;
      };

      var inputCount = 0;

      //DESCRIPTION: create new destination/waypoint input HTML elements
      var createInput = function () {
        if (inputCount < 3){
          inputCount++;            
          var solidPanelDiv = document.getElementById('solidPanel');
          var inputBody = solidPanelDiv.children[1].cloneNode(true);
          var icon = inputBody.getElementsByTagName('div')[1];
          var input = inputBody.getElementsByTagName('input')[0];

          icon.innerHTML = "<button id='delButton' class='button delButton'>X</button>";
          //icon.innerHTML = "";

          input.className += 'waypoint-field';
          input.id = 'waypoint_' + (inputCount);
          input.value = "";
          input.placeholder = "Enter Waypoint";
          solidPanelDiv.insertBefore(inputBody, solidPanelDiv.children[1+inputCount]);

          createDelButtonID(inputCount); 
          createDelButtonHandler(inputCount);

          destinationAutoComplete = new google.maps.places.Autocomplete((document.getElementById('waypoint_' + (inputCount))));         
        } 
      };
      //DESCRIPTION: produces every possible sequence/order of the elements of an array
      //ex. ABC ==> ABC, ACB, BCA, BAC, CAB, CBA
      function allCombinations (startingIndex, result, lastPush){

        for (var i = 1; startingIndex <= result[0].length-2; i++){

          var holder = lastPush.slice(0);
          
          allCombinations(startingIndex + 1, result, holder);

          if (startingIndex + i <= result[0].length-1){
            result.push(rotate(lastPush, startingIndex));   
          } else {return result;}   
        }
      }

      //DESCRIPTION: rotates values of an array starting w/ a specified index 'start'
      //e.g. ABC will become BCA
      function rotate (arr, start){
        var holder = arr[start];
        for (var i = start; i < arr.length-1; i++){
          arr[i] = arr[i+1];
        }
          arr[arr.length-1] = holder;
          return arr.slice(0);
      }

      function changePanel(){
        container.classList.toggle('panel-change');
      }

      //DESCRIPTION: enables and disables optimizeRouteButton
      function testOptimize () {
              if (inputCount > 1){
                optimizeButton.disabled = false;
              } else { optimizeButton.disabled = true;} 
      }

      function createDelButtonID (count) {
        var delButton = document.getElementById('delButton');
        delButton.id = 'delButton_' + count;
      }

      function createDelButtonHandler (count) {
        var delButton = document.querySelector('#delButton_'+ count);
        delButton.addEventListener('click', function (delButton) {return function () {
            deleteButtonHandler(delButton);
          }
        });
      }

      function deleteWaypoint (target) {
        targetNode = document.getElementById('solidPanel');
        targetNode.removeChild(targetNode.getElementsByClassName('nav-row-Solid')[getTarget(target.id)]);
      }

      function getTarget (id) {
        var target = id.slice(-1);
        return target;

      }

      function deleteButtonHandler (input) {
        deleteWaypoint(input);
        //fix waypoints array
      }

      //DESCRIPTION: deletes waypoint input fields & supporting div's
      function deleteWaypoints () {
        var targetNode;
        var waypointInputs = document.getElementsByClassName('waypoint-field');
        var waypointsArr = toArr(waypointInputs);

        waypointsArr.forEach(function (){
          targetNode = document.getElementById('solidPanel');
          targetNode.removeChild(targetNode.getElementsByClassName('nav-row-Solid')[1]);
        });

        inputCount = 0;
      }

      //clears all input fields
      function clearInputs () {
        var inputFields = document.getElementsByTagName('input');

        Array.prototype.forEach.call(inputFields, function (element){
          element.value = "";
        });
     }
      
      //DESCRIPTION: stores waypoints in an array
      var storeWaypoints = function () {
        var waypointsArr = [];
        var waypointInputs = document.getElementsByClassName('waypoint-field');

        waypointsArr = Array.prototype.map.call(waypointInputs, function (waypoint) {
            waypointObj = {};
            waypointObj["location"] = waypoint.value;
            return waypointObj;
        });

        return waypointsArr;
      };

      //DESCRIPTION: stores waypoints of the current Optimal Route in a passed-in array
      function storeOptimalWaypoints (element) {
        if(element.end_address !== element[element.length-1].end_address){
          optimalRoute.push({location: element.end_address});}
      }

      //assigns the optimal travel duration to optimatlTravleTime
      function setMostEfficient (current, optimal, action) {
        if (current < optimal || optimal === 0){
          optimal = current;
          if (typeof action === 'function'){ action();
            return optimal;
          } 
        } 
        return optimal;

      }

      function pullData (objArr, values){
        var newArr = [];
        //var vObj = {};

        values.forEach(function (val, index){
          var valArr = objArr.map(function (obj, objIndex){
            //create proper property call using bracket notation
            return getPropertyVal(obj, val);
            //return obj[val];
          })
          newArr.push(valArr);
        })

      function getPropertyVal (obj, property){
        var propArr = [];
        var val = obj;

        propArr = property.split('.');
        propArr.forEach(function (element) {
          val = val[element];
        })
        return val;
      }
       
        return newArr;
      }

      function displayRouteInfo (routeInfo){
        //var legInfoArr = [];
        var legInfoArr = routeInfo;

        //legInfoArr = createUnits(routeInfo);
        //display start + end destinations, duration, distance

        legInfoArr.forEach(function (priEl, priIndex){
            //create HTML (function?)
            createRouteInfoCard();

            //define variables
            var startVar = document.getElementById('startVar_' + infoCardCount);
            var endVar = document.getElementById('endVar_' + infoCardCount);
            var durVar = document.getElementById('durVar_' + infoCardCount);

            //reassign values to variables
            startVar.innerHTML = legInfoArr[0][priIndex];
            endVar.innerHTML = legInfoArr[1][priIndex];
            durVar.innerHTML = legInfoArr[2][priIndex];

            // startVar.innerHTML = legInfoArr[priIndex][0];
            // endVar.innerHTML = legInfoArr[priIndex][1];
            // durVar.innerHTML = legInfoArr[priIndex][2];
         
        })   
      }

      var infoCardCount = 0;

      function createRouteInfoCard () {
        infoCardCount++;

        var routeInfoDisplay = document.getElementById('routeInfoDisplay');

        //this is ugly and confusing
        //received errors when new lines were placed between the ""'s 
        var infoCard =  "<div class='legInfoCard'> <div class='infoDiv infoLeft'> <div class='infoTitle'>Start</div> <div id='startVar' class='infoContent'></div> </div> <div class='infoDiv infoRight'> <div class='infoTitle'> End</div> <div id='endVar' class='infoContent'></div> </div> <div class='infoDiv infoRight'> <div class='infoTitle'>Duration</div> <div id='durVar' class='infoContent'></div> </div> </div>";

        routeInfoDisplay.innerHTML += infoCard;


        //give id's to divs that will have variable values inserted
        var startVar = document.getElementById('startVar');
        startVar.id = 'startVar_' + infoCardCount;

        var endVar = document.getElementById('endVar');
        endVar.id = 'endVar_' + infoCardCount;

        var durVar = document.getElementById('durVar');
        durVar.id = 'durVar_' + infoCardCount;
      }

      //TODO: replace one of the for's w/ a .forEach() AND/OR .map()
      function createUnits (infoArr) {
        var unitsArr = [];
        var aUnit = [];

        unitsArr = infoArr[0].map(function (priEL, priIndex){
          return infoArr.map(function (secEl, secIndex){
            return secEl[priIndex];
          })
        })

        // for (var i = 0; i < infoArr.length; i++){
        //   for (var x = 0; x < infoArr.length; x++){
        //     aUnit.push(infoArr[x][i])
        //   }
        //   unitsArr.push(aUnit.slice(0));
        //   aUnit = [];
        // }

        // infoArr.forEach(function (priEl, priIndex){
        //   unitsArr.push(infoArr.map(function (secEL, secIndex){
        //     return infoArr[secIndex][priIndex];
        //   }))
        // })
        return unitsArr;
      }

      function toArr (arrLike) {
        return Array.prototype.slice.call(arrLike);
      }

      //Maps API  
      function initMap() {
        //Google Map Api Default Code
        var directionsService = new google.maps.DirectionsService;
        var directionsDisplay = new google.maps.DirectionsRenderer;
        var map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 37.7833, lng: -122.4167},
          zoom: 13
        });

        //DESCRIPTION: initializes AutoComplete for input fields
        startAutocomplete = new google.maps.places.Autocomplete((document.getElementById('startFloat')));

        endAutocomplete = new google.maps.places.Autocomplete((document.getElementById('endDestinationFloat')));

        startAutocompleteSolid = new google.maps.places.Autocomplete((document.getElementById('startSolid')));

        destination_1AutocompleteSolid = new google.maps.places.Autocomplete((document.getElementById('endDestinationSolid')));

        places = new google.maps.places.PlacesService(map);

        

        //DESCRIPTION: Changes map Location to address selected from AutoComplete
        startAutocomplete.addListener('place_changed', onPlaceChanged);

        //Google Map Api Default Code
        function onPlaceChanged() {
          var place = startAutocomplete.getPlace();
          if (place.geometry) {
            map.panTo(place.geometry.location);
            map.setZoom(15);
          } else {
            document.getElementById('startFloat').placeholder = 'Enter Origin Address';
          }
        }

        //DESCRIPTION: Calculates and displays directions
        directionsDisplay.setMap(map);


        //DESCRIPTION: Button Handlers
        function goButtonFloatHandler () {
          floatToSolid();
          changePanel();
          calcRoute(storeWaypoints(), false);
         }

        function goButtonSolidHandler () {
          storeWaypoints();
          calcRoute(storeWaypoints(), false);
         }

        function addButtonFloatHandler () {
          floatToSolid();
          createInput();
          changePanel();
         }

        function clearButtonSolidHandler () {
          deleteWaypoints();
          clearInputs();
          changePanel();
          testOptimize();
         }

        function addButtonSolidHandler () {
          createInput();
          testOptimize();
          //makeDeleteButtonHandlers();
         }

        function optimizeButtonHandler () {
          calcRoute(storeWaypoints(), true);
         }

        

        //DESCRIPTION: Assignment of Button Actions
      goButtonFloat.addEventListener('click', goButtonFloatHandler);
      addButtonFloat.addEventListener('click', addButtonFloatHandler);
      clearButtonFloat.addEventListener('click', clearInputs);

      goButtonSolid.addEventListener('click', goButtonSolidHandler);
      addButtonSolid.addEventListener('click', addButtonSolidHandler);
      clearButtonSolid.addEventListener('click', clearButtonSolidHandler);
      optimizeButton.addEventListener('click', optimizeButtonHandler);
      //delButton.addEventListener('click', deleteButtonHandler(delButton));

        function calcRoute(waypoints, optimizeRoute) {
          var start = document.getElementById('startSolid').value;
          var destination_1 = document.getElementById('endDestinationSolid').value;          
          var waypointsArray = [];
          var travelTime = 0;
          var optimalTravelTime = 0;
          routeInfo = [];
          optimalRoute = [];
          var numRoute = 0;
          var gateOpen = true;

          if (waypoints.length > 0){
            waypointsArray.push(waypoints.slice(0));
          }

          //IF optimizing route produce an array 
          //of all possible waypoint sequences
          if (optimizeRoute){
            allCombinations (0, waypointsArray, waypoints.slice(0)); 
          }

          var x = 0;
          do {  
            var request = {
              origin: start,
              destination: destination_1,
              waypoints: waypointsArray[x],
              optimizeWaypoints: false, //I build this feature
              travelMode: google.maps.TravelMode.DRIVING
           };
           x++;

          directionsService.route(request, function(result, status) {
            
            travelTime = 0;

            //TODO: simplify? use w/out valuesNameArr
            routeInfo = pullData(result.routes[0].legs, ["start_address", "end_address", "duration.value"]);

            //get total travel duration for the route currently analyzed IF the route has waypoints
            if (waypointsArray.length > 1){

              travelTime = routeInfo[2].reduce(function (previousVal, currentVal){return previousVal + currentVal;})

              // result.routes[0].legs.forEach(function(element){
              //   travelTime += element.duration.value;
              // });
            }

            if (optimizeRoute){
              optimalTravelTime = setMostEfficient(travelTime, optimalTravelTime, function(){
                optimalRoute = [];
                result.routes[0].legs.forEach(function(element){optimalRoute.push({location: element.end_address});
                });
                //'end_address' of the last 'leg' is equal to 'destination'
                //delete the value at the last index in order to avoid mapping error
                optimalRoute.pop();
              });

              if (numRoute === waypointsArray.length-1 && gateOpen){
                gateOpen = false;
                calcRoute(optimalRoute, false);
              } 
            } else if (status === google.maps.DirectionsStatus.OK) {
                displayRouteInfo(routeInfo);
                directionsDisplay.setDirections(result);
                }

            numRoute++;                  
          });
        } while (x < waypointsArray.length);
      } 
    }

    </script>

    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDikBEU0kR-r0r_3Vibn1nvggdauVED7Zg&signed_in=true&libraries=places&callback=initMap"
        async defer></script>
        
  </body>
</html>

